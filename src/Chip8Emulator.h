#ifndef CHIP8_EMULATOR_H
#define CHIP8_EMULATOR_H

#include <array>
#include <climits>
#include <cstdint>
#include <functional>
#include <stack>
#include <unordered_map>

#include "Chip8Instructions.h"
#include "Instruction.h"

using Chip8Function = std::function<void(Chip8System&)>;
using Chip8InstructionFunction = std::function<void(Chip8System&, Instruction)>;

using Chip8FunctionVariant = std::variant<Chip8Function, Chip8InstructionFunction>;

struct OpcodeRow
{
    uint16_t mask;
    uint16_t value;
    Chip8FunctionVariant execute;
};

const std::array<OpcodeRow, 41> DECODE_TABLE
{{
  { .mask=0xFFF0, .value=0x00C0, .execute=Chip8Instructions::sc_down },
  { .mask=0xFFFF, .value=0x00E0, .execute=Chip8Instructions::cls },
  { .mask=0xFFFF, .value=0x00EE, .execute=Chip8Instructions::ret },
  { .mask=0xFFFF, .value=0x00FB, .execute=Chip8Instructions::sc_right },
  { .mask=0xFFFF, .value=0x00FC, .execute=Chip8Instructions::sc_left },
  { .mask=0xFFFF, .value=0x00FD, .execute=Chip8Instructions::exit },
  { .mask=0xFFFF, .value=0x00FE, .execute=Chip8Instructions::lores },
  { .mask=0xFFFF, .value=0x00FF, .execute=Chip8Instructions::hires },
  { .mask=0xF000, .value=0x1000, .execute=Chip8Instructions::jmp },
  { .mask=0xF000, .value=0x2000, .execute=Chip8Instructions::call },
  { .mask=0xF000, .value=0x3000, .execute=Chip8Instructions::seq_vx_nn },
  { .mask=0xF000, .value=0x4000, .execute=Chip8Instructions::sne_vx_nn },
  { .mask=0xF000, .value=0x5000, .execute=Chip8Instructions::seq_vx_vy },
  { .mask=0xF000, .value=0x6000, .execute=Chip8Instructions::mov_vx_nn },
  { .mask=0xF000, .value=0x7000, .execute=Chip8Instructions::add_vx_nn },
  { .mask=0xF00F, .value=0x8000, .execute=Chip8Instructions::mov_vx_vy },
  { .mask=0xF00F, .value=0x8001, .execute=Chip8Instructions::or_vx_vy },
  { .mask=0xF00F, .value=0x8002, .execute=Chip8Instructions::and_vx_vy },
  { .mask=0xF00F, .value=0x8003, .execute=Chip8Instructions::xor_vx_vy },
  { .mask=0xF00F, .value=0x8004, .execute=Chip8Instructions::add_vx_vy },
  { .mask=0xF00F, .value=0x8005, .execute=Chip8Instructions::sub_vx_vy },
  { .mask=0xF00F, .value=0x8006, .execute=Chip8Instructions::shr_vx_vy },
  { .mask=0xF00F, .value=0x8007, .execute=Chip8Instructions::rsb_vx_vy },
  { .mask=0xF00F, .value=0x800E, .execute=Chip8Instructions::shl_vx_vy },
  { .mask=0xF000, .value=0x9000, .execute=Chip8Instructions::sne_vx_vy },
  { .mask=0xF000, .value=0xA000, .execute=Chip8Instructions::mov_i_nnn },
  { .mask=0xF000, .value=0xB000, .execute=Chip8Instructions::jmp_vx_nnn },
  { .mask=0xF000, .value=0xC000, .execute=Chip8Instructions::rnd_vx_nn },
  { .mask=0xF000, .value=0xD000, .execute=Chip8Instructions::drw },
  { .mask=0xF0FF, .value=0xE09E, .execute=Chip8Instructions::spr_vx },
  { .mask=0xF0FF, .value=0xE0A1, .execute=Chip8Instructions::sup_vx },
  { .mask=0xF0FF, .value=0xF007, .execute=Chip8Instructions::mov_vx_dt },
  { .mask=0xF0FF, .value=0xF00A, .execute=Chip8Instructions::wait_mov_vx_key },
  { .mask=0xF0FF, .value=0xF015, .execute=Chip8Instructions::mov_dt_vx },
  { .mask=0xF0FF, .value=0xF018, .execute=Chip8Instructions::mov_st_vx },
  { .mask=0xF0FF, .value=0xF01E, .execute=Chip8Instructions::add_i_vx },
  { .mask=0xF0FF, .value=0xF029, .execute=Chip8Instructions::mov_i_font_vx },
  { .mask=0xF0FF, .value=0xF030, .execute=Chip8Instructions::mov_i_bfont_vx },
  { .mask=0xF0FF, .value=0xF033, .execute=Chip8Instructions::mov_i_bcd_vx },
  { .mask=0xF0FF, .value=0xF055, .execute=Chip8Instructions::mov_i_vx },
  { .mask=0xF0FF, .value=0xF065, .execute=Chip8Instructions::mov_vx_i }
}};

class Chip8Emulator
{
public:
  Chip8Emulator();
  
  Chip8System system{};

  void decodeInstruction(Instruction instruction);

  void loadRom(std::string &filename);

  bool updateTimers() noexcept;

  [[nodiscard]] Instruction getCurrentInstruction() const;

  auto cycle() -> int;
};

// normal font, size is 5 x F = 50
static constexpr std::array<std::uint8_t, 0x50> FONT = {
  0xF0, 0x90, 0x90, 0x90, 0xF0,  // 0
  0x20, 0x60, 0x20, 0x20, 0x70,  // 1
  0xF0, 0x10, 0xF0, 0x80, 0xF0,  // 2
  0xF0, 0x10, 0xF0, 0x10, 0xF0,  // 3
  0x90, 0x90, 0xF0, 0x10, 0x10,  // 4
  0xF0, 0x80, 0xF0, 0x10, 0xF0,  // 5
  0xF0, 0x80, 0xF0, 0x90, 0xF0,  // 6
  0xF0, 0x10, 0x20, 0x40, 0x40,  // 7
  0xF0, 0x90, 0xF0, 0x90, 0xF0,  // 8
  0xF0, 0x90, 0xF0, 0x10, 0xF0,  // 9
  0xF0, 0x90, 0xF0, 0x90, 0x90,  // A
  0xE0, 0x90, 0xE0, 0x90, 0xE0,  // B
  0xF0, 0x80, 0x80, 0x80, 0xF0,  // C
  0xE0, 0x90, 0x90, 0x90, 0xE0,  // D
  0xF0, 0x80, 0xF0, 0x80, 0xF0,  // E
  0xF0, 0x80, 0xF0, 0x80, 0x80   // F
};

// big font, size is A x F = A0
static constexpr std::array<std::uint8_t, 0xA0> BIG_FONT = {
  0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
  0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
  0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
  0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
  0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
  0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
  0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
  0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
  0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
  0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
  0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
  0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
  0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
  0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
  0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
  0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
};

#endif
